KMP算法是求解字符串匹配问题的经典算法。

给定长度为 $m$ 的字符主串 $t$ 、长度为 $n$ 的字符模式串 $s$，求 $s$ 在 $t$ 中出现的位置。对于 $m < n$ 的情况，即模式串比主串长，显然不存在匹配情况。以下讨论 $m\geq n$ 的情况。

## Brute Force（朴素算法）
一种很自然的求解方法是，将 $s$ 的第一个字符与 $t$ 的第1个对齐，逐字符进行比较，若未能完成完整匹配，将 $s$ 向后移动一个字符，使得 $s$ 的第1个字符与 $t$ 的第2个字符对齐，然后重新从头逐字符匹配。若仍然未能完成完整匹配，将 $s$ 向后移动1位，继续匹配，一直如此进行下去，直到找到完整匹配结果或者没有匹配。

![模式串匹配朴素算法示意图](https://github.com/user-attachments/assets/481cb94b-123b-450b-b002-0a67dd449e2b)

如上图，使用主串 $t$ 来匹配模式串 $s$，在第 $\textrm{1}$ 轮匹配不成功时， $s$ 模式串向后移动一位，并从头开始第 $\textrm{2}$ 轮匹配，一直如此进行下去。

## KMP（Keep-Matching-Prefixes🫣）
以上过程中对每一个位置都进行了匹配判断，其中也包括一些显然不匹配的情况，例如对于主串中不等于模式串第一个字符的位置，显然不会是最终的匹配结果，对于这类诸如此类的位置，进入新轮次遇到时，可以直接跳过。

那当上一轮匹配失败进入下一轮匹配时，模式串应该移动多少位置才能完美那些避开不必要的匹配呢？或者说，对于最终能够匹配的位置，会有什么特点呢，直接移动到满足这个特点的位置，就意味着满足了达成最终匹配的必要条件（在这样的位置可能成功匹配，但是不满足这样的位置一定不能成功匹配，这自然减少了很多不必要的匹配）。

如下图，在某一轮匹配时，前11个字符都顺利匹配，但是 $t[11] \neq t[11]$ ，即第12个位置上的字符不匹配。假设最终匹配结果如图，是6号位置开始的匹配，即有 $t[6:19]=s[0:13]$ 。而由上一轮的匹配结果可知： $t[0-10]=s[0-10]$。

![成功匹配必要条件示意图1](https://github.com/user-attachments/assets/4dfeef11-8df9-441d-942c-3b688277ac10)

由此我们容易推出， $s[0:4]=t[6:10]=s[6:10$ ，即下图中紫色区域的字符子串对应相等。

![成功匹配必要条件示意图2](https://github.com/user-attachments/assets/93e32a5e-71e9-4c5e-a0bc-e0ec63f9d8c3)

对于模式串来说， $s[0:4]=s[6:10]$ ，如下图，表示存在模式子串 $s[0:10]$ 的前缀 $s[0:4]$ 等于其后缀 $s[6:10]$ 。

![成功匹配必要条件示意图3](https://github.com/user-attachments/assets/32eb05f0-a41c-447d-b359-e45c064f6c7d)

这也就是说，当某一轮匹配中，匹配到模式串第12个字符 $s[11]$ 失败时，只需要直接移动模式串 $s$ ，使得 $s[0:10]$ 的前缀 $s[0:4]$ 移动到其后缀 $s[6:10]$ 的位置。匹配过程如下图所示：

![成功匹配必要条件示意图4](https://github.com/user-attachments/assets/f01c94cf-d7ba-4017-9f43-91f7a63cb572)

经过以上的例子，可以知道，在任意一轮匹配中，当发生不匹配时，求出模式串中不匹配位置前的子串的最长公共前后缀，移动模式串使得前缀对应到后缀位置。这便是满足成功匹配的的必要性的方法。

## 一些细节讨论和进一步优化

### 为何是寻找最长的公共前后缀？

### 每次不匹配都要取寻找吗？能否优化

## GREEDY 还能再继续优化吗
